// <auto-generated>
//     This code was generated by the BoundedContext Code Generator.
//     Generation Stamp: {{generationStamp}}
//     Generated: {{generatedAt}}
//     Source: {{sourceFile}}
// </auto-generated>

#nullable enable

using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore;
using {{namespace}}.Domain.Entities;
using {{namespace}}.Domain.Services;
using {{namespace}}.Domain.Validators;
using {{namespace}}.Domain.DbContexts;
using {{namespace}}.DTO.ADTs;

namespace {{namespace}}.API.Tests.Services;

public class {{entityName}}SearchServiceTests
{
    [Fact]
    public async Task ExecuteSearchAsync_ReturnsFailure_WhenQueryInvalid()
    {
        var repository = new Mock<IRepository<{{entityName}}>>();
        var queryBuilder = new Mock<IQueryBuilder<{{entityName}}>>();
        var projectionMapper = new Mock<IProjectionMapper<{{entityName}}, {{projectionName}}>>();
        var expressionBuilder = new ProjectionExpressionBuilder();
        var validator = new {{entityName}}SearchQueryValidator();
        var logger = new Mock<ILogger<{{searchServiceName}}>>();

        var service = new {{searchServiceName}}(
            repository.Object,
            queryBuilder.Object,
            projectionMapper.Object,
            expressionBuilder,
            validator,
            logger.Object);

        var invalidQuery = new SearchQuery(pagination: new PageRequest(0, 10));

        var result = await service.ExecuteSearchAsync(invalidQuery);

        result.IsSuccess.Should().BeFalse();
    }

    [Fact]
    public async Task ExecuteSearchAsync_ReturnsSuccess_WhenQueryValid()
    {
        var options = new DbContextOptionsBuilder<{{contextName}}DbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
        using var context = new {{contextName}}DbContext(options);

        var entity = CreateEntity();
        context.Set<{{entityName}}>().Add(entity);
        context.SaveChanges();

        var queryable = context.Set<{{entityName}}>();
        var repository = new Mock<IRepository<{{entityName}}>>();
        var queryBuilder = new Mock<IQueryBuilder<{{entityName}}>>();
        var projectionMapper = new Mock<IProjectionMapper<{{entityName}}, {{projectionName}}>>();
        var expressionBuilder = new ProjectionExpressionBuilder();
        var validator = new {{entityName}}SearchQueryValidator();
        var logger = new Mock<ILogger<{{searchServiceName}}>>();

        repository.Setup(r => r.GetQueryable()).Returns(queryable);
        queryBuilder.Setup(q => q.BuildQuery(queryable, It.IsAny<SearchQuery>())).Returns(queryable);

        Expression<Func<{{entityName}}, {{projectionName}}>> projection = entity => new {{projectionName}}
        {
            Id = entity.Id
        };
        projectionMapper.Setup(m => m.GetProjectionExpression(It.IsAny<ProjectionRequest?>())).Returns(projection);

        var service = new {{searchServiceName}}(
            repository.Object,
            queryBuilder.Object,
            projectionMapper.Object,
            expressionBuilder,
            validator,
            logger.Object);

        var query = new SearchQuery(pagination: new PageRequest(1, 10));

        var result = await service.ExecuteSearchAsync(query);

        result.IsSuccess.Should().BeTrue();
        result.Data.Should().NotBeNull();
        result.Data!.Items.Should().HaveCount(1);
    }

    private static {{entityName}} CreateEntity()
    {
        return new {{entityName}}(
            {{#each constructorArgs}}
            {{{value}}}{{#unless @last}},{{/unless}}
            {{/each}}
        );
    }

}
