// <auto-generated>
//     This code was generated by the BoundedContext Code Generator.
//     Generation Stamp: {{generationStamp}}
//     Generated: {{generatedAt}}
//     Source: {{sourceFile}}
//
//     Changes to this file will be lost when regenerated.
// </auto-generated>

using FluentValidation;
using Inventorization.Base.ADTs;
using Inventorization.Base.Metadata;
using {{namespace}}.Domain.Constants;

namespace {{namespace}}.Domain.Validators;

/// <summary>
/// Validates SearchQuery objects for {{entityName}} entity.
/// Uses metadata-driven validation for field types and operators.
/// </summary>
public class {{entityName}}SearchQueryValidator : AbstractValidator<SearchQuery>
{
    private static readonly DataModelMetadata Metadata = DataModelMetadata.Instance;
    private const string EntityName = "{{entityName}}";

    public {{entityName}}SearchQueryValidator()
    {
        RuleFor(x => x.Filters)
            .Must(BeValidFilters)
            .WithMessage("Invalid filter configuration");

        RuleFor(x => x.Projection)
            .Must(BeValidProjection)
            .When(x => x.Projection != null)
            .WithMessage("Invalid projection configuration");

        RuleFor(x => x.Sorts)
            .Must(BeValidSorts)
            .When(x => x.Sorts != null && x.Sorts.Any())
            .WithMessage("Invalid sort configuration");

        RuleFor(x => x.Pagination)
            .Must(BeValidPagination)
            .When(x => x.Pagination != null)
            .WithMessage("Invalid pagination configuration");
    }

    private bool BeValidFilters(FilterExpression? filter)
    {
        if (filter == null) return true;

        return filter.Type switch
        {
            FilterType.Comparison => ValidateComparisonFilter(filter),
            FilterType.Logical => ValidateLogicalFilter(filter),
            FilterType.In => ValidateInFilter(filter),
            FilterType.Between => ValidateBetweenFilter(filter),
            _ => false
        };
    }

    private bool ValidateComparisonFilter(FilterExpression filter)
    {
        if (string.IsNullOrWhiteSpace(filter.Field))
            return false;

        if (!{{entityName}}SearchFields.IsValidField(filter.Field))
            return false;

        var fieldMetadata = Metadata.GetPropertyMetadata(EntityName, filter.Field);
        if (fieldMetadata == null)
            return false;

        return ValidateOperatorForType(filter.Operator, fieldMetadata);
    }

    private bool ValidateLogicalFilter(FilterExpression filter)
    {
        if (filter.Filters == null || !filter.Filters.Any())
            return false;

        return filter.Filters.All(BeValidFilters);
    }

    private bool ValidateInFilter(FilterExpression filter)
    {
        if (string.IsNullOrWhiteSpace(filter.Field))
            return false;

        if (!{{entityName}}SearchFields.IsValidField(filter.Field))
            return false;

        if (filter.Values == null || !filter.Values.Any())
            return false;

        return true;
    }

    private bool ValidateBetweenFilter(FilterExpression filter)
    {
        if (string.IsNullOrWhiteSpace(filter.Field))
            return false;

        if (!{{entityName}}SearchFields.IsValidField(filter.Field))
            return false;

        if (filter.Value == null || filter.MaxValue == null)
            return false;

        var fieldMetadata = Metadata.GetPropertyMetadata(EntityName, filter.Field);
        if (fieldMetadata == null)
            return false;

        return {{#each validationTypes}}fieldMetadata.{{checkProperty}}{{#unless @last}} || {{/unless}}{{/each}};
    }

    private bool ValidateOperatorForType(ComparisonOperator op, PropertyMetadata metadata)
    {
        return op switch
        {
            ComparisonOperator.Equal or ComparisonOperator.NotEqual
                => true, // Valid for all types

            ComparisonOperator.GreaterThan or
            ComparisonOperator.GreaterThanOrEqual or
            ComparisonOperator.LessThan or
            ComparisonOperator.LessThanOrEqual
                => metadata.IsNumeric || metadata.IsDateTime,

            ComparisonOperator.Contains or
            ComparisonOperator.StartsWith or
            ComparisonOperator.EndsWith
                => metadata.IsString,

            _ => false
        };
    }

    private bool BeValidProjection(ProjectionRequest? projection)
    {
        if (projection == null) return true;

        if (projection.Fields == null || !projection.Fields.Any())
            return true; // Empty projection means all fields

        return projection.Fields.All(f =>
            !string.IsNullOrWhiteSpace(f.FieldName) &&
            {{entityName}}SearchFields.IsValidField(f.FieldName));
    }

    private bool BeValidSorts(List<SortField>? sorts)
    {
        if (sorts == null || !sorts.Any())
            return true;

        return sorts.All(s =>
            !string.IsNullOrWhiteSpace(s.Field) &&
            {{entityName}}SearchFields.IsValidField(s.Field));
    }

    private bool BeValidPagination(PaginationRequest? pagination)
    {
        if (pagination == null) return true;

        return pagination.Page > 0 &&
               pagination.PageSize > 0 &&
               pagination.PageSize <= 1000; // Max page size limit
    }
}
