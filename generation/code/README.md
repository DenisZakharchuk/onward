# BoundedContext Code Generator

Automated code generator for creating complete BoundedContext microservices in the Inventorization system.

## Features

- üöÄ **Full Project Generation** - Creates all layers: DTO, Domain, API, Tests
- üìã **JSON Schema Input** - Type-safe data model definitions
- ÔøΩ **Generation Stamps** - Each run gets unique 16-char identifier for traceability
- ‚ôªÔ∏è **Regeneration Safe** - All files can be regenerated; custom logic in separate services
- ‚úÖ **Test Scaffolding** - Generates unit test stubs
- üê≥ **Docker Integration** - Updates docker-compose.yml automatically
- üéØ **Architecture Compliance** - Follows patterns from Architecture.md

## Generation Strategy

### Generated vs Custom Code

- **Generated Files**: All `.cs` files generated from metadata (can be overwritten on regeneration)
- **Custom Business Logic**: Implemented in separate domain services (developer-owned)

Example:
```csharp
// Product.cs - GENERATED (can be regenerated)
public class Product : BaseEntity { ... }

// ProductDomainService.cs - CUSTOM LOGIC (developer-owned)
public class ProductDomainService : IProductDomainService
{
    public void ActivateProduct(Product product) { /* custom logic */ }
}
```

### Generation Stamp

Every generation run creates a unique **generationStamp** (format: `YYYYMMDD-XXXXXXXX`) that appears in all generated files:

```csharp
// <auto-generated>
//     Generation Stamp: 20260208-d45df1a4
//     Generated: 2026-02-08 20:40:27 UTC
//     Source: simple-bounded-context.json
// </auto-generated>
```

This enables:
- Tracking which files belong to the same generation batch
- Identifying outdated files from previous generations
- Debugging generation issues

## Installation

```bash
cd generation/code
npm install
npm run build
```

## Usage

### Generate a BoundedContext

```bash
npm start generate examples/simple-bounded-context.json -- --output-dir ../../backend
```

### Validate Data Model

```bash
npm start validate examples/simple-bounded-context.json
```

### CLI Options

- `--output-dir <path>` - Target directory for generated code (default: `../../backend`)
- `--namespace <name>` - Override namespace prefix (default: from JSON)
- `--skip-tests` - Don't generate test projects
- `--dry-run` - Preview what would be generated without writing files
- `--force` - Overwrite existing generated files (default: true)

## Data Model Format

See [schemas/data-model.schema.json](schemas/data-model.schema.json) for complete specification.

### Foreign Keys & Navigation Properties

**Important**: Foreign key properties and navigation properties are separate:

**Foreign Key Property** - Regular Guid/int property:
```json
{
  "name": "CategoryId",
  "type": "Guid",
  "required": true,
  "isForeignKey": true,
  "referencedEntity": "Category",
  "navigationProperty": "Category",
  "description": "Category ID"
}
```

Generates:
```csharp
public Guid CategoryId { get; private set; }           // FK property
public Category Category { get; } = null!;              // Navigation property
```

**Collection Navigation** - Defined in relationships:
```json
{
  "type": "OneToMany",
  "leftEntity": "Category",
  "rightEntity": "Product",
  "leftNavigationProperty": "Products",
  "rightNavigationProperty": "Category"
}
```

Generates on Category:
```csharp
public ICollection<Product> Products { get; } = new List<Product>();
```

**Key Rules**:
- FK properties are Guid/int properties (included in constructor)
- Navigation property name comes from `navigationProperty` field
- Collection navigation properties defined in `relationships` array
- Navigation properties are read-only, not settable

Example:

```json
{
  "boundedContext": {
    "name": "Products",
    "namespace": "Inventorization.Products",
    "description": "Product catalog management"
  },
  "entities": [
    {
      "name": "Product",
      "tableName": "Products",
      "description": "Product in catalog",
      "properties": [
        {
          "name": "Name",
          "type": "string",
          "required": true,
          "maxLength": 200,
          "description": "Product name"
        },
        {
          "name": "Price",
          "type": "decimal",
          "required": true,
          "precision": 18,
          "scale": 2
        },
        {
          "name": "CategoryId",
          "type": "Guid",
          "required": true,
          "isForeignKey": true,
          "referencedEntity": "Category",
          "navigationProperty": "Category",
          "description": "Category ID"
        }
      ]
    }
  ],
  "relationships": [
    {
      "type": "OneToMany",
      "leftEntity": "Category",
      "rightEntity": "Product",
      "leftNavigationProperty": "Products",
      "rightNavigationProperty": "Category"
    }
  ]
}
```

## Generated Project Structure

```
Inventorization.{Context}.DTO/
‚îú‚îÄ‚îÄ DTO/{Entity}/
‚îÇ   ‚îú‚îÄ‚îÄ Create{Entity}DTO.cs
‚îÇ   ‚îú‚îÄ‚îÄ Update{Entity}DTO.cs
‚îÇ   ‚îú‚îÄ‚îÄ Delete{Entity}DTO.cs
‚îÇ   ‚îú‚îÄ‚îÄ {Entity}DetailsDTO.cs
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}SearchDTO.cs

Inventorization.{Context}.Domain/
‚îú‚îÄ‚îÄ Entities/
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}.cs (fully regeneratable)
‚îú‚îÄ‚îÄ EntityConfigurations/
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}Configuration.cs (planned)
‚îú‚îÄ‚îÄ Creators/
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}Creator.cs (planned)
‚îú‚îÄ‚îÄ Modifiers/
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}Modifier.cs (planned)
‚îú‚îÄ‚îÄ Mappers/
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}Mapper.cs (planned)
‚îú‚îÄ‚îÄ SearchProviders/
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}SearchProvider.cs (planned)
‚îú‚îÄ‚îÄ Validators/
‚îÇ   ‚îú‚îÄ‚îÄ Create{Entity}Validator.cs (planned)
‚îÇ   ‚îî‚îÄ‚îÄ Update{Entity}Validator.cs (planned)
‚îú‚îÄ‚îÄ DataServices/
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}DataService.cs (planned)
‚îú‚îÄ‚îÄ DbContexts/
‚îÇ   ‚îî‚îÄ‚îÄ {Context}DbContext.cs (planned)
‚îú‚îÄ‚îÄ DataAccess/
‚îÇ   ‚îî‚îÄ‚îÄ {Context}UnitOfWork.cs (planned)
‚îî‚îÄ‚îÄ DataModelMetadata.cs (planned)

Inventorization.{Context}.API/
‚îú‚îÄ‚îÄ Controllers/
‚îÇ   ‚îî‚îÄ‚îÄ {Entity}sController.cs (planned)
‚îî‚îÄ‚îÄ Program.cs (planned - DI registrations)

Inventorization.{Context}.API.Tests/
‚îî‚îÄ‚îÄ (planned - test scaffolds)
```

**Note**: Currently only Entity and DTO generators are implemented. All files are fully regeneratable - metadata is the source of truth.

## Custom Business Logic

All generated files can be safely regenerated - **do not modify generated code directly**.

Custom business logic should be implemented in separate service classes:

- **{Entity}DomainService.cs** - Custom business logic, complex operations
- **Custom Validators** - FluentValidation rules beyond metadata
- **Custom Controllers** - Additional endpoints not in generated CRUD

Example:
```csharp
// Product.cs - GENERATED (can be overwritten)
public class Product : BaseEntity
{
    public string Name { get; private set; }
    public decimal Price { get; private set; }
}

// ProductDomainService.cs - CUSTOM (developer-owned)
public class ProductDomainService : IProductDomainService
{
    public void ActivateProduct(Product product)
    {
        // Custom business logic here
    }
    
    public bool CanDiscontinue(Product product)
    {
        // Complex validation logic
        return product.Price > 0 && product.Stock == 0;
    }
}
```

**Benefits**:
- Metadata is the single source of truth
- Regeneration is safe and encouraged
- Clear separation between data model and business logic
- Easier to maintain and evolve the codebase

## Architecture Compliance

Generated code follows all rules from [Architecture.md](../../Architecture.md):

- ‚úÖ Base abstractions from Inventorization.Base
- ‚úÖ Dependency injection with interfaces
- ‚úÖ Immutable entities with private setters
- ‚úÖ Generic data services
- ‚úÖ IMapper abstraction for object mapping
- ‚úÖ DTO inheritance from base DTOs
- ‚úÖ Entity configurations with fluent API
- ‚úÖ Unit test scaffolding

## Development

```bash
# Watch mode
npm run dev

# Format code
npm run format

# Lint
npm run lint

# Clean build artifacts
npm run clean
```

## License

MIT
