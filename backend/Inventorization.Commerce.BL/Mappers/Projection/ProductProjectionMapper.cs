// <auto-generated>
//     This code was generated by the BoundedContext Code Generator.
//     Generation Stamp: 20260222-f94ae12e
//     Generated: 2026-02-22 17:37:05 UTC
//     Source: simple-bounded-context.json
//
//     Changes to this file will be lost when regenerated.
//     Override methods in partial class for custom projection logic.
// </auto-generated>

using System.Linq.Expressions;
using Inventorization.Base.Abstractions;
using Inventorization.Base.ADTs;
using Inventorization.Commerce.BL.Entities;
using Inventorization.Commerce.DTO.ADTs;

namespace Inventorization.Commerce.BL.Mappers.Projection;

/// <summary>
/// Projection mapper for Product entity.
/// Implements template methods for EF Core expressions and in-memory mapping.
/// </summary>
public class ProductProjectionMapper : ProjectionMapperBase<Product, ProductProjection>, IProductProjectionMapper
{
    private readonly ICategoryProjectionMapper _categoryMapper;

    public ProductProjectionMapper(
        ICategoryProjectionMapper categoryMapper
    )
    {
        _categoryMapper = categoryMapper;
    }

    protected override Expression<Func<Product, ProductProjection>> GetAllFieldsProjection(bool deep, int depth)
    {
        return entity => new ProductProjection
        {
            Name = entity.Name,
            SKU = entity.SKU,
            Description = entity.Description,
            Price = entity.Price,
            StockQuantity = entity.StockQuantity,
            Status = entity.Status,
            IsActive = entity.IsActive,
            Category = deep && depth > 0 && entity.Category != null
                ? new CategoryProjection
                {
                    Id = entity.Category.Id,
                }
                : null,
        };
    }

    protected override Expression<Func<Product, ProductProjection>> BuildSelectiveProjection(
        ProjectionRequest projection)
    {
        // Evaluate field checks OUTSIDE expression tree for EF Core compatibility
        var requestedFields = new HashSet<string>(
            projection.Fields.Select(f => f.FieldName),
            StringComparer.OrdinalIgnoreCase);

        var hasName = requestedFields.Contains("Name");
        var hasSKU = requestedFields.Contains("SKU");
        var hasDescription = requestedFields.Contains("Description");
        var hasPrice = requestedFields.Contains("Price");
        var hasStockQuantity = requestedFields.Contains("StockQuantity");
        var hasStatus = requestedFields.Contains("Status");
        var hasIsActive = requestedFields.Contains("IsActive");
        var hasCategory = requestedFields.Contains("Category.Id") || requestedFields.Contains("Category.Name");

        // Use boolean constants in expression tree
        return entity => new ProductProjection
        {
            Name = hasName ? entity.Name : null,
            SKU = hasSKU ? entity.SKU : null,
            Description = hasDescription ? entity.Description : null,
            Price = hasPrice ? entity.Price : null,
            StockQuantity = hasStockQuantity ? entity.StockQuantity : null,
            Status = hasStatus ? entity.Status : null,
            IsActive = hasIsActive ? entity.IsActive : null,
            Category = hasCategory && entity.Category != null
                ? new CategoryProjection
                {
                    Id = entity.Category.Id,
                }
                : null,
        };
    }

    protected override void MapAllFields(
        Product entity,
        ProductProjection result,
        bool deep,
        int maxDepth,
        int currentDepth)
    {
        // Map all scalar properties
        result.Name = entity.Name;
        result.SKU = entity.SKU;
        result.Description = entity.Description;
        result.Price = entity.Price;
        result.StockQuantity = entity.StockQuantity;
        result.Status = entity.Status;
        result.IsActive = entity.IsActive;

        // Map related entities with depth control
        if (deep && currentDepth < maxDepth && entity.Category != null)
        {
            var categoryProjection = ProjectionRequest.AllDeep(maxDepth - currentDepth - 1);
            result.Category = _categoryMapper.Map(
                entity.Category,
                categoryProjection,
                currentDepth + 1
            );
        }
    }

    protected override void MapField(
        Product entity,
        ProductProjection result,
        FieldProjection field,
        int currentDepth)
    {
        var fieldName = field.FieldName.ToLower();
        
        switch (fieldName)
        {
            case "name":
                result.Name = entity.Name;
                break;
            case "sKU":
                result.SKU = entity.SKU;
                break;
            case "description":
                result.Description = entity.Description;
                break;
            case "price":
                result.Price = entity.Price;
                break;
            case "stockQuantity":
                result.StockQuantity = entity.StockQuantity;
                break;
            case "status":
                result.Status = entity.Status;
                break;
            case "isActive":
                result.IsActive = entity.IsActive;
                break;
            case "category.id":
                if (entity.Category != null)
                {
                    result.Category ??= new CategoryProjection();
                    result.Category.Id = entity.Category.Id;
                }
                break;
            case "category.name":
                if (entity.Category != null)
                {
                    result.Category ??= new CategoryProjection();
                    // Assuming related entity has Name property
                    // Adjust if needed
                }
                break;
        }
    }
}
