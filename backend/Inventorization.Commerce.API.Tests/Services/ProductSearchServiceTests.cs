// <auto-generated>
//     This code was generated by the BoundedContext Code Generator.
//     Generation Stamp: 20260214-29e15abc
//     Generated: 2026-02-14 20:07:27 UTC
//     Source: simple-bounded-context.json
// </auto-generated>

#nullable enable

using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore;
using Inventorization.Commerce.Domain.Entities;
using Inventorization.Commerce.Domain.Services;
using Inventorization.Commerce.Domain.Validators;
using Inventorization.Commerce.Domain.DbContexts;
using Inventorization.Commerce.DTO.ADTs;

namespace Inventorization.Commerce.API.Tests.Services;

public class ProductSearchServiceTests
{
    [Fact]
    public async Task ExecuteSearchAsync_ReturnsFailure_WhenQueryInvalid()
    {
        var repository = new Mock<IRepository<Product>>();
        var queryBuilder = new Mock<IQueryBuilder<Product>>();
        var projectionMapper = new Mock<IProjectionMapper<Product, ProductProjection>>();
        var expressionBuilder = new ProjectionExpressionBuilder();
        var validator = new ProductSearchQueryValidator();
        var logger = new Mock<ILogger<ProductSearchService>>();

        var service = new ProductSearchService(
            repository.Object,
            queryBuilder.Object,
            projectionMapper.Object,
            expressionBuilder,
            validator,
            logger.Object);

        var invalidQuery = new SearchQuery(pagination: new PageRequest(0, 10));

        var result = await service.ExecuteSearchAsync(invalidQuery);

        result.IsSuccess.Should().BeFalse();
    }

    [Fact]
    public async Task ExecuteSearchAsync_ReturnsSuccess_WhenQueryValid()
    {
        var options = new DbContextOptionsBuilder<CommerceDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
        using var context = new CommerceDbContext(options);

        var entity = CreateEntity();
        context.Set<Product>().Add(entity);
        context.SaveChanges();

        var queryable = context.Set<Product>();
        var repository = new Mock<IRepository<Product>>();
        var queryBuilder = new Mock<IQueryBuilder<Product>>();
        var projectionMapper = new Mock<IProjectionMapper<Product, ProductProjection>>();
        var expressionBuilder = new ProjectionExpressionBuilder();
        var validator = new ProductSearchQueryValidator();
        var logger = new Mock<ILogger<ProductSearchService>>();

        repository.Setup(r => r.GetQueryable()).Returns(queryable);
        queryBuilder.Setup(q => q.BuildQuery(queryable, It.IsAny<SearchQuery>())).Returns(queryable);

        Expression<Func<Product, ProductProjection>> projection = entity => new ProductProjection
        {
            Id = entity.Id
        };
        projectionMapper.Setup(m => m.GetProjectionExpression(It.IsAny<ProjectionRequest?>())).Returns(projection);

        var service = new ProductSearchService(
            repository.Object,
            queryBuilder.Object,
            projectionMapper.Object,
            expressionBuilder,
            validator,
            logger.Object);

        var query = new SearchQuery(pagination: new PageRequest(1, 10));

        var result = await service.ExecuteSearchAsync(query);

        result.IsSuccess.Should().BeTrue();
        result.Data.Should().NotBeNull();
        result.Data!.Items.Should().HaveCount(1);
    }

    private static Product CreateEntity()
    {
        return new Product(
            new string('a', 1),
            "SKU-1",
            new string('a', 1),
            0m,
            0,
            Guid.NewGuid(),
            ProductStatus.Draft,
            true
        );
    }

}
