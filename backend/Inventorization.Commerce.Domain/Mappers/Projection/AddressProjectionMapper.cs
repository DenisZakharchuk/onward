// <auto-generated>
//     This code was generated by the BoundedContext Code Generator.
//     Generation Stamp: 20260215-717476ad
//     Generated: 2026-02-15 18:29:05 UTC
//     Source: simple-bounded-context.json
//
//     Changes to this file will be lost when regenerated.
//     Override methods in partial class for custom projection logic.
// </auto-generated>

using System.Linq.Expressions;
using Inventorization.Base.Abstractions;
using Inventorization.Base.ADTs;
using Inventorization.Commerce.Domain.Entities;
using Inventorization.Commerce.DTO.ADTs;

namespace Inventorization.Commerce.Domain.Mappers.Projection;

/// <summary>
/// Projection mapper for Address entity.
/// Implements template methods for EF Core expressions and in-memory mapping.
/// </summary>
public class AddressProjectionMapper : ProjectionMapperBase<Address, AddressProjection>, IAddressProjectionMapper
{
    private readonly ICustomerProjectionMapper _customerMapper;

    public AddressProjectionMapper(
        ICustomerProjectionMapper customerMapper
    )
    {
        _customerMapper = customerMapper;
    }

    protected override Expression<Func<Address, AddressProjection>> GetAllFieldsProjection(bool deep, int depth)
    {
        return entity => new AddressProjection
        {
            AddressType = entity.AddressType,
            Street = entity.Street,
            City = entity.City,
            State = entity.State,
            PostalCode = entity.PostalCode,
            Country = entity.Country,
            IsDefault = entity.IsDefault,
            Customer = deep && depth > 0 && entity.Customer != null
                ? new CustomerProjection
                {
                    Id = entity.Customer.Id,
                }
                : null,
        };
    }

    protected override Expression<Func<Address, AddressProjection>> BuildSelectiveProjection(
        ProjectionRequest projection)
    {
        // Evaluate field checks OUTSIDE expression tree for EF Core compatibility
        var requestedFields = new HashSet<string>(
            projection.Fields.Select(f => f.FieldName),
            StringComparer.OrdinalIgnoreCase);

        var hasAddressType = requestedFields.Contains("AddressType");
        var hasStreet = requestedFields.Contains("Street");
        var hasCity = requestedFields.Contains("City");
        var hasState = requestedFields.Contains("State");
        var hasPostalCode = requestedFields.Contains("PostalCode");
        var hasCountry = requestedFields.Contains("Country");
        var hasIsDefault = requestedFields.Contains("IsDefault");
        var hasCustomer = requestedFields.Contains("Customer.Id") || requestedFields.Contains("Customer.Name");

        // Use boolean constants in expression tree
        return entity => new AddressProjection
        {
            AddressType = hasAddressType ? entity.AddressType : null,
            Street = hasStreet ? entity.Street : null,
            City = hasCity ? entity.City : null,
            State = hasState ? entity.State : null,
            PostalCode = hasPostalCode ? entity.PostalCode : null,
            Country = hasCountry ? entity.Country : null,
            IsDefault = hasIsDefault ? entity.IsDefault : null,
            Customer = hasCustomer && entity.Customer != null
                ? new CustomerProjection
                {
                    Id = entity.Customer.Id,
                }
                : null,
        };
    }

    protected override void MapAllFields(
        Address entity,
        AddressProjection result,
        bool deep,
        int maxDepth,
        int currentDepth)
    {
        // Map all scalar properties
        result.AddressType = entity.AddressType;
        result.Street = entity.Street;
        result.City = entity.City;
        result.State = entity.State;
        result.PostalCode = entity.PostalCode;
        result.Country = entity.Country;
        result.IsDefault = entity.IsDefault;

        // Map related entities with depth control
        if (deep && currentDepth < maxDepth && entity.Customer != null)
        {
            var customerProjection = ProjectionRequest.AllDeep(maxDepth - currentDepth - 1);
            result.Customer = _customerMapper.Map(
                entity.Customer,
                customerProjection,
                currentDepth + 1
            );
        }
    }

    protected override void MapField(
        Address entity,
        AddressProjection result,
        FieldProjection field,
        int currentDepth)
    {
        var fieldName = field.FieldName.ToLower();
        
        switch (fieldName)
        {
            case "addressType":
                result.AddressType = entity.AddressType;
                break;
            case "street":
                result.Street = entity.Street;
                break;
            case "city":
                result.City = entity.City;
                break;
            case "state":
                result.State = entity.State;
                break;
            case "postalCode":
                result.PostalCode = entity.PostalCode;
                break;
            case "country":
                result.Country = entity.Country;
                break;
            case "isDefault":
                result.IsDefault = entity.IsDefault;
                break;
            case "customer.id":
                if (entity.Customer != null)
                {
                    result.Customer ??= new CustomerProjection();
                    result.Customer.Id = entity.Customer.Id;
                }
                break;
            case "customer.name":
                if (entity.Customer != null)
                {
                    result.Customer ??= new CustomerProjection();
                    // Assuming related entity has Name property
                    // Adjust if needed
                }
                break;
        }
    }
}
