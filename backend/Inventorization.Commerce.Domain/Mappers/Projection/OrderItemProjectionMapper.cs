// <auto-generated>
//     This code was generated by the BoundedContext Code Generator.
//     Generation Stamp: 20260214-76e7efc9
//     Generated: 2026-02-14 15:34:46 UTC
//     Source: simple-bounded-context.json
//
//     Changes to this file will be lost when regenerated.
//     Override methods in partial class for custom projection logic.
// </auto-generated>

using System.Linq.Expressions;
using Inventorization.Base.Abstractions;
using Inventorization.Base.ADTs;
using Inventorization.Commerce.Domain.Entities;
using Inventorization.Commerce.DTO.ADTs;

namespace Inventorization.Commerce.Domain.Mappers.Projection;

/// <summary>
/// Projection mapper for OrderItem entity.
/// Implements template methods for EF Core expressions and in-memory mapping.
/// </summary>
public class OrderItemProjectionMapper : ProjectionMapperBase<OrderItem, OrderItemProjection>, IOrderItemProjectionMapper
{
    private readonly IOrderProjectionMapper _orderMapper;
    private readonly IProductProjectionMapper _productMapper;

    public OrderItemProjectionMapper(
        IOrderProjectionMapper orderMapper,
        IProductProjectionMapper productMapper
    )
    {
        _orderMapper = orderMapper;
        _productMapper = productMapper;
    }

    protected override Expression<Func<OrderItem, OrderItemProjection>> GetAllFieldsProjection(bool deep, int depth)
    {
        return entity => new OrderItemProjection
        {
            Quantity = entity.Quantity,
            UnitPrice = entity.UnitPrice,
            TotalPrice = entity.TotalPrice,
            Order = deep && depth > 0 && entity.Order != null
                ? new OrderProjection
                {
                    Id = entity.Order.Id,
                }
                : null,
            Product = deep && depth > 0 && entity.Product != null
                ? new ProductProjection
                {
                    Id = entity.Product.Id,
                }
                : null,
        };
    }

    protected override Expression<Func<OrderItem, OrderItemProjection>> BuildSelectiveProjection(
        ProjectionRequest projection)
    {
        // Evaluate field checks OUTSIDE expression tree for EF Core compatibility
        var requestedFields = new HashSet<string>(
            projection.Fields.Select(f => f.FieldName),
            StringComparer.OrdinalIgnoreCase);

        var hasQuantity = requestedFields.Contains("Quantity");
        var hasUnitPrice = requestedFields.Contains("UnitPrice");
        var hasTotalPrice = requestedFields.Contains("TotalPrice");
        var hasOrder = requestedFields.Contains("Order.Id") || requestedFields.Contains("Order.Name");
        var hasProduct = requestedFields.Contains("Product.Id") || requestedFields.Contains("Product.Name");

        // Use boolean constants in expression tree
        return entity => new OrderItemProjection
        {
            Quantity = hasQuantity ? entity.Quantity : null,
            UnitPrice = hasUnitPrice ? entity.UnitPrice : null,
            TotalPrice = hasTotalPrice ? entity.TotalPrice : null,
            Order = hasOrder && entity.Order != null
                ? new OrderProjection
                {
                    Id = entity.Order.Id,
                }
                : null,
            Product = hasProduct && entity.Product != null
                ? new ProductProjection
                {
                    Id = entity.Product.Id,
                }
                : null,
        };
    }

    protected override void MapAllFields(
        OrderItem entity,
        OrderItemProjection result,
        bool deep,
        int maxDepth,
        int currentDepth)
    {
        // Map all scalar properties
        result.Quantity = entity.Quantity;
        result.UnitPrice = entity.UnitPrice;
        result.TotalPrice = entity.TotalPrice;

        // Map related entities with depth control
        if (deep && currentDepth < maxDepth && entity.Order != null)
        {
            var orderProjection = ProjectionRequest.AllDeep(maxDepth - currentDepth - 1);
            result.Order = _orderMapper.Map(
                entity.Order,
                orderProjection,
                currentDepth + 1
            );
        }
        if (deep && currentDepth < maxDepth && entity.Product != null)
        {
            var productProjection = ProjectionRequest.AllDeep(maxDepth - currentDepth - 1);
            result.Product = _productMapper.Map(
                entity.Product,
                productProjection,
                currentDepth + 1
            );
        }
    }

    protected override void MapField(
        OrderItem entity,
        OrderItemProjection result,
        FieldProjection field,
        int currentDepth)
    {
        var fieldName = field.FieldName.ToLower();
        
        switch (fieldName)
        {
            case "quantity":
                result.Quantity = entity.Quantity;
                break;
            case "unitPrice":
                result.UnitPrice = entity.UnitPrice;
                break;
            case "totalPrice":
                result.TotalPrice = entity.TotalPrice;
                break;
            case "order.id":
                if (entity.Order != null)
                {
                    result.Order ??= new OrderProjection();
                    result.Order.Id = entity.Order.Id;
                }
                break;
            case "order.name":
                if (entity.Order != null)
                {
                    result.Order ??= new OrderProjection();
                    // Assuming related entity has Name property
                    // Adjust if needed
                }
                break;
            case "product.id":
                if (entity.Product != null)
                {
                    result.Product ??= new ProductProjection();
                    result.Product.Id = entity.Product.Id;
                }
                break;
            case "product.name":
                if (entity.Product != null)
                {
                    result.Product ??= new ProductProjection();
                    // Assuming related entity has Name property
                    // Adjust if needed
                }
                break;
        }
    }
}
